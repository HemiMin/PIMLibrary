/*
 * Copyright (C) 2021 Samsung Electronics Co. LTD
 *
 * This software is a property of Samsung Electronics.
 * No part of this software, either material or conceptual may be copied or distributed, transmitted,
 * transcribed, stored in a retrieval system or translated into any human or computer language in any form by any means,
 * electronic, mechanical, manual or otherwise, or disclosed
 * to third parties without the express written permission of Samsung Electronics.
 */

#ifndef _PIM_GEMV_KERNELS_PIMK_
#define _PIM_GEMV_KERNELS_PIMK_

#define PREPARE_KERNEL 1
#define PARK_IN 1
#define CHANGE_SB_HAB 1
#define PROGRAM_CRF 1
#define COMPUTE_GEMV 1
#define CHANGE_HAB_SB 1
#define PARK_OUT 1
#ifdef TARGET
#define REDUCE_SUM 1
#endif

__global__ void gemv_pim_64cu_64th_fp16(volatile uint8_t* __restrict__ pim_ctr,
                                        volatile uint8_t* __restrict__ pim_weight,
                                        volatile uint8_t* __restrict__ pim_gemv_tmp_buffer,
                                        volatile uint8_t* __restrict__ pim_input, volatile uint8_t* __restrict__ output,
                                        int batch_dim, int n_memory_tile, int n_compute_tile, int n_out_tile,
                                        int output_dim,
#ifdef EMULATOR
                                        PimMemTraceData* fmtd16, int* frd_size, int mt_width,
                                        PimMemTracer* emulator_trace,
#endif
                                        uint8_t* crf_binary, int crf_size, int is_gemv_add)
{
#ifdef EMULATOR
    emulator_trace->g_fba = (uint64_t)pim_ctr;
    emulator_trace->g_fmtd16 = fmtd16;
    emulator_trace->g_ridx[hipBlockIdx_x] = 0;
    emulator_trace->m_width = mt_width;
    __syncthreads();
#endif

#ifdef PREPARE_KERNEL
    int num_grf = 8;
    int num_bg = 4;
    int num_ba = 4;
    int num_col = 32;
    int trans_size = 32;
    int even_row, odd_row, row, col, loc;
    int ch = hipBlockIdx_x;
    int w_idx = hipThreadIdx_x % 2;
    int gidx = hipThreadIdx_x / 2;
    uint64_t offset = w_idx * 0x10;
    uint64_t addr;
#endif

#if PARK_IN
    /* park */
    if (hipThreadIdx_x < 32) {
        addr = addr_gen(ch, 0, gidx / num_ba, gidx % num_ba, (1 << 13), 0);
        W_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
    }
#endif

#if CHANGE_SB_HAB
    if (hipThreadIdx_x < 2) {
        /* change SB mode to HAB mode */
        addr = addr_gen(ch, 0, 2, 0, 0x27ff, 0x1f);
        W_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
        addr = addr_gen(ch, 0, 2, 1, 0x27ff, 0x1f);
        W_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
        addr = addr_gen(ch, 0, 0, 0, 0x27ff, 0x1f);
        W_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
        addr = addr_gen(ch, 0, 0, 1, 0x27ff, 0x1f);
        W_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
    }
#endif

#if PROGRAM_CRF
    if (hipThreadIdx_x < (crf_size >> 4)) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 1, 0x3fff, 0x4 + gidx);
        W_CMD_R(&pim_ctr[addr + offset], crf_binary + (hipThreadIdx_x << 4));
        R_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
    }
#endif

#if COMPUTE_GEMV
    if (hipThreadIdx_x < 16) {
        /* change HAB mode to HAB_PIM mode */
        for (int b_idx = 0; b_idx < batch_dim; b_idx++) {
            for (int o_idx = 0; o_idx < n_out_tile; o_idx++) {
                addr = addr_gen(ch, 0, 0, 0, 0x3fff, 0x0);
                W_CMD_R(&pim_ctr[addr + offset], gemv_hab_to_hab_pim + offset);
                R_CMD(&pim_ctr[addr + offset]);
                B_CMD(1);

                uint64_t i_offset = b_idx * n_memory_tile * num_grf;
                int r_offset = (o_idx * n_memory_tile) / 2;

                for (int i_idx = 0; i_idx < n_compute_tile; i_idx += 2) {
                    /* write grf_A from WRIO */
                    uint64_t i_addr = (i_offset + (i_idx * num_grf + gidx)) * trans_size;
                    addr = addr_gen(ch, 0, 0, 0, 0x3fff, 0x8 + gidx);
                    W_CMD_R(&pim_ctr[addr + offset], &pim_input[i_addr + offset]);
                    R_CMD(&pim_ctr[addr + offset]);
                    B_CMD(1);

                    even_row = ((i_idx / 2) + r_offset) * 2;
                    odd_row = even_row + 1;

                    addr = addr_gen(ch, 0, 0, 0, even_row, gidx);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 0, even_row, gidx + 8);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 0, even_row, gidx + 16);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 0, even_row, gidx + 24);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 0, odd_row, gidx);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 0, odd_row, gidx + 8);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 0, odd_row, gidx + 16);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 0, odd_row, gidx + 24);
                    R_CMD(&pim_weight[addr + offset]);
                    B_CMD(1);
                }

                for (int i_idx = 1; i_idx < n_compute_tile; i_idx += 2) {
                    uint64_t i_addr = (i_offset + (i_idx * num_grf + gidx)) * trans_size;
                    addr = addr_gen(ch, 0, 0, 1, 0x3fff, 0x8 + gidx);
                    W_CMD_R(&pim_ctr[addr + offset], &pim_input[i_addr + offset]);
                    R_CMD(&pim_ctr[addr + offset]);
                    B_CMD(1);

                    even_row = ((i_idx / 2) + r_offset) * 2;
                    odd_row = even_row + 1;

                    addr = addr_gen(ch, 0, 0, 1, even_row, gidx);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 1, even_row, gidx + 8);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 1, even_row, gidx + 16);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 1, even_row, gidx + 24);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 1, odd_row, gidx);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 1, odd_row, gidx + 8);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 1, odd_row, gidx + 16);
                    R_CMD(&pim_weight[addr + offset]);

                    addr = addr_gen(ch, 0, 0, 1, odd_row, gidx + 24);
                    R_CMD(&pim_weight[addr + offset]);
                    B_CMD(1);
                }
                loc = b_idx * n_out_tile * num_grf + o_idx * num_grf + gidx;
                row = loc / num_col;
                col = loc % num_col;

                // pipeline delay
                // FIX : If alu is in operation, NOP should be added.
                addr = addr_gen(ch, 0, 0, 1, row, col);
                W_CMD(&pim_gemv_tmp_buffer[addr + offset]);
                W_CMD(&pim_gemv_tmp_buffer[addr + offset]);
                R_CMD(&pim_gemv_tmp_buffer[addr + offset]);
                B_CMD(1);

                addr = addr_gen(ch, 0, 0, 0, 0x3fff, 0x0);
                W_CMD_R(&pim_ctr[addr + offset], gemv_hab_pim_to_hab + offset);
                R_CMD(&pim_ctr[addr + offset]);
                B_CMD(1);
            }
        }
    }
#endif

#if CHANGE_HAB_SB
    if (hipThreadIdx_x < 4) {
        /* change HAB mode to SB mode */
        addr = addr_gen(ch, 0, 0, gidx, 0x2fff, 0x1f);
        W_CMD(&pim_ctr[addr + offset]);
        R_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
    }
#endif

#if PARK_OUT
    /* park */
    if (hipThreadIdx_x < 32) {
        addr = addr_gen(ch, 0, gidx / num_ba, gidx % num_ba, (1 << 13), 0);
        W_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
    }
#endif

#ifdef EMULATOR
    if (hipBlockIdx_x == 0 && hipThreadIdx_x == 0) {
        frd_size[0] = emulator_trace->g_ridx[0];
    }
#endif

#if REDUCE_SUM
    int out_per_tile = 4096;
    int bg = hipThreadIdx_x / 16;
    int ba = (((hipThreadIdx_x / 8) % 2) * 2) + 1;
    int t_idx = (hipBlockIdx_x * 64) + hipThreadIdx_x;
    int out_idx;
    int out_offset;
    int li;
    half t_output;

    for (int bi = 0; bi < batch_dim; bi++) {
        for (int oi = 0; oi < n_out_tile; oi++) {
            out_idx = oi * out_per_tile + t_idx;
            if (out_idx < output_dim) {
                li = bi * n_out_tile + oi;
                row = li / 4;
                col = hipThreadIdx_x % 8 + ((li % 4) * 8);
                addr = addr_gen(ch, 0, bg, ba, row, col);
                t_output = 0;
                for (int ti = 0; ti < 16; ti++) {
                    t_output += ((half*)pim_gemv_tmp_buffer)[(addr >> 1) + ti];
                }
                out_offset = bi * output_dim + out_idx;
                if (is_gemv_add)
                    ((half*)output)[out_offset] += t_output;
                else
                    ((half*)output)[out_offset] = t_output;
            }
        }
    }
#endif
}

__global__ void gemv_tree_pim_64cu_64th_fp16(
    volatile uint8_t* __restrict__ pim_ctr, volatile uint8_t* __restrict__ pim_weight,
    volatile uint8_t* __restrict__ pim_gemv_tmp_buffer, volatile uint8_t* __restrict__ zero_buffer,
    volatile uint8_t* __restrict__ pim_input, volatile uint8_t* __restrict__ output, int batch_dim, int n_memory_tile,
    int n_compute_tile, int n_out_tile, int output_dim,
#ifdef EMULATOR
    PimMemTraceData* fmtd16, int* frd_size, int mt_width, PimMemTracer* emulator_trace,
#endif
    uint8_t* crf_binary, int crf_size, int is_gemv_add)
{
#ifdef EMULATOR
    emulator_trace->g_fba = (uint64_t)pim_ctr;
    emulator_trace->g_fmtd16 = fmtd16;
    emulator_trace->g_ridx[hipBlockIdx_x] = 0;
    emulator_trace->m_width = mt_width;
    __syncthreads();
#endif

#ifdef PREPARE_KERNEL
    int num_grf = 8;
    int num_bg = 4;
    int num_ba = 4;
    int num_col = 32;
    int trans_size = 32;
    int even_row, odd_row, row, col, loc;
    int ch = hipBlockIdx_x;
    int w_idx = hipThreadIdx_x % 2;
    int gidx = hipThreadIdx_x / 2;
    uint64_t offset = w_idx * 0x10;
    uint64_t addr;
#endif

#if PARK_IN
    /* park */
    if (hipThreadIdx_x < 32) {
        addr = addr_gen(ch, 0, gidx / num_ba, gidx % num_ba, (1 << 13), 0);
        W_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
    }
#endif

#if CHANGE_SB_HAB
    if (hipThreadIdx_x < 2) {
        /* change SB mode to HAB mode */
        addr = addr_gen(ch, 0, 2, 0, 0x27ff, 0x1f);
        W_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
        addr = addr_gen(ch, 0, 2, 1, 0x27ff, 0x1f);
        W_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
        addr = addr_gen(ch, 0, 0, 0, 0x27ff, 0x1f);
        W_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
        addr = addr_gen(ch, 0, 0, 1, 0x27ff, 0x1f);
        W_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
    }
#endif

#if PROGRAM_CRF
    if (hipThreadIdx_x < (crf_size >> 4)) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 1, 0x3fff, 0x4 + gidx);
        W_CMD_R(&pim_ctr[addr + offset], crf_binary + (hipThreadIdx_x << 4));
        R_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
    }
#endif

#if COMPUTE_GEMV
    if (hipThreadIdx_x < 16) {
        /* change HAB mode to HAB_PIM mode */
        for (int b_idx = 0; b_idx < batch_dim; b_idx++) {
            for (int o_idx = 0; o_idx < n_out_tile; o_idx++) {
                addr = addr_gen(ch, 0, 0, 0, 0x3fff, 0x0);
                W_CMD_R(&pim_ctr[addr + offset], gemv_hab_to_hab_pim + offset);
                R_CMD(&pim_ctr[addr + offset]);
                B_CMD(1);

                uint64_t i_offset = b_idx * n_memory_tile * num_grf;
                int r_offset = (o_idx * n_memory_tile) / 2;

                for (int i_idx = 0; i_idx < n_compute_tile; i_idx++) {
                    /* write grf_A from WRIO */
                    uint64_t i_addr = (i_offset + (i_idx * num_grf + gidx)) * trans_size;
                    addr = addr_gen(ch, 0, 0, 0, 0x3fff, 0x8 + gidx);
                    W_CMD_R(&pim_ctr[addr + offset], &pim_input[i_addr + offset]);
                    R_CMD(&pim_ctr[addr + offset]);
                    B_CMD(1);

                    even_row = ((i_idx / 2) + r_offset) * 2;
                    odd_row = even_row + 1;

                    if (i_idx % 2 == 0) {
                        addr = addr_gen(ch, 0, 0, 0, even_row, gidx);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 0, even_row, gidx + 8);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 0, even_row, gidx + 16);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 0, even_row, gidx + 24);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 0, odd_row, gidx);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 0, odd_row, gidx + 8);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 0, odd_row, gidx + 16);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 0, odd_row, gidx + 24);
                        R_CMD(&pim_weight[addr + offset]);
                        B_CMD(1);

                        loc = b_idx * n_out_tile * n_compute_tile * num_grf + o_idx * num_grf * n_compute_tile +
                              i_idx * num_grf + gidx;
                        row = loc / num_col;
                        col = loc % num_col;

                        // pipeline delay
                        // FIX : If alu is in operation, NOP should be added.
                        addr = addr_gen(ch, 0, 0, 1, row, col);
                        W_CMD(&pim_gemv_tmp_buffer[addr + offset]);
                        W_CMD(&pim_gemv_tmp_buffer[addr + offset]);
                        R_CMD(&pim_gemv_tmp_buffer[addr + offset]);
                        B_CMD(1);

                        /* write grf_B from WRIO */
                        addr = addr_gen(ch, 0, 0, 0, 0x3fff, 0x18 + gidx);
                        W_CMD_R(&pim_ctr[addr + offset], &zero_buffer[offset]);
                        B_CMD(1);

                    } else {
                        addr = addr_gen(ch, 0, 0, 1, even_row, gidx);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 1, even_row, gidx + 8);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 1, even_row, gidx + 16);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 1, even_row, gidx + 24);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 1, odd_row, gidx);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 1, odd_row, gidx + 8);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 1, odd_row, gidx + 16);
                        R_CMD(&pim_weight[addr + offset]);

                        addr = addr_gen(ch, 0, 0, 1, odd_row, gidx + 24);
                        R_CMD(&pim_weight[addr + offset]);
                        B_CMD(1);

                        loc = b_idx * n_out_tile * n_compute_tile * num_grf + o_idx * num_grf * n_compute_tile +
                              i_idx * num_grf + gidx;
                        row = loc / num_col;
                        col = loc % num_col;

                        // pipeline delay
                        // FIX : If alu is in operation, NOP should be added.
                        addr = addr_gen(ch, 0, 0, 1, row, col);
                        W_CMD(&pim_gemv_tmp_buffer[addr + offset]);
                        W_CMD(&pim_gemv_tmp_buffer[addr + offset]);
                        R_CMD(&pim_gemv_tmp_buffer[addr + offset]);
                        B_CMD(1);

                        /* write grf_B from WRIO */
                        addr = addr_gen(ch, 0, 0, 0, 0x3fff, 0x18 + gidx);
                        W_CMD_R(&pim_ctr[addr + offset], &zero_buffer[offset]);
                        B_CMD(1);
                    }
                }

                addr = addr_gen(ch, 0, 0, 0, 0x3fff, 0x0);
                W_CMD_R(&pim_ctr[addr + offset], gemv_hab_pim_to_hab + offset);
                R_CMD(&pim_ctr[addr + offset]);
                B_CMD(1);
            }
        }
    }
#endif

#if CHANGE_HAB_SB
    if (hipThreadIdx_x < 4) {
        /* change HAB mode to SB mode */
        addr = addr_gen(ch, 0, 0, gidx, 0x2fff, 0x1f);
        W_CMD(&pim_ctr[addr + offset]);
        R_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
    }
#endif

#if PARK_OUT
    /* park */
    if (hipThreadIdx_x < 32) {
        addr = addr_gen(ch, 0, gidx / num_ba, gidx % num_ba, (1 << 13), 0);
        W_CMD(&pim_ctr[addr + offset]);
        B_CMD(1);
    }
#endif

#ifdef EMULATOR
    if (hipBlockIdx_x == 0 && hipThreadIdx_x == 0) {
        frd_size[0] = emulator_trace->g_ridx[0];
    }
#endif

#if REDUCE_SUM
    int out_per_tile = 4096;
    int bg = hipThreadIdx_x / 16;
    int ba = (((hipThreadIdx_x / 8) % 2) * 2) + 1;
    int t_idx = (hipBlockIdx_x * 64) + hipThreadIdx_x;
    int out_idx;
    int out_offset;
    int li;

    // FIXME
    float t_output[32];
    float temp_sum[16];
    int num_data = 16;

    for (int bi = 0; bi < batch_dim; bi++) {
        for (int oi = 0; oi < n_out_tile; oi++) {
            out_idx = oi * out_per_tile + t_idx;
            li = bi * n_out_tile * n_compute_tile + oi * n_compute_tile;
            if (out_idx < output_dim) {
                for (int tile_idx = 0; tile_idx < n_compute_tile; tile_idx++) {
                    row = li / 4 + (((li % 4) + tile_idx) / 4);
                    col = hipThreadIdx_x % 8 + (((li + tile_idx) % 4) * 8);

                    addr = addr_gen(ch, 0, bg, ba, row, col);

                    for (int ti = 0; ti < 16; ti++) {
                        temp_sum[ti] = __half2float(((half*)pim_gemv_tmp_buffer)[(addr >> 1) + ti]);
                    }

                    num_data = 16;
                    for (int i = 0; i < 4; i++) {
                        num_data = num_data / 2;
                        for (int j = 0; j < num_data; j++) {
                            temp_sum[j] = temp_sum[j * 2] + temp_sum[j * 2 + 1];
                        }
                    }

                    t_output[tile_idx] = temp_sum[0];
                }

                int num_tile = n_compute_tile;
                int iter;

                while (num_tile > 1) {
                    iter = num_tile / 2;
                    for (int j = 0; j < iter; j++) {
                        t_output[j] = t_output[j * 2] + t_output[j * 2 + 1];
                    }

                    if (num_tile % 2 == 1) {
                        t_output[iter] = t_output[num_tile];
                        num_tile = num_tile / 2 + 1;
                    } else {
                        num_tile = num_tile / 2;
                    }
                }
                out_offset = bi * output_dim + out_idx;
                if (is_gemv_add)
                    ((half*)output)[out_offset] += __float2half(t_output[0]);
                else
                    ((half*)output)[out_offset] = __float2half(t_output[0]);
            }
        }
    }
#endif
}
#endif /* _PIM_GEMV_KERNELS_PIMK_ */
