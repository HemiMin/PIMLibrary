#ifndef _FIM_OP_KERNELS_FIMK_
#define _FIM_OP_KERNELS_FIMK_

#include "fim_data_types.h"
#include "utility/fim_util.h"
#include "fim_crf_bins.h"

#ifdef EMULATOR
uint64_t g_fba;
FimMemTraceData* g_fmtd16;
int g_ridx;
#endif

__device__ void record(uint8_t *fim, FimMemTraceData *mt, int width, int bid, int tid, int midx, char mtype, uint64_t paddr, uint64_t mdata1, uint64_t mdata2)
{
    int row = bid * width;

    mt[row + midx].data[0] = mdata1;
    mt[row + midx].data[1] = mdata2;
    mt[row + midx].addr = paddr;
    mt[row + midx].block_id = bid;
    mt[row + midx].thread_id = tid;
    mt[row + midx].cmd = mtype;
}

__global__ void dummy_kernel(void)
{
}

__global__ void elt_add_fim_1cu_1th_fp16(
    volatile uint8_t* __restrict__ fim_data,
    volatile uint8_t* __restrict__ fim_ctr,
    volatile uint8_t* __restrict__ output,
    int size,
    FimMemTraceData* fmtd16,
    int* frd_size)
{
#ifdef EMULATOR
    g_fba = (uint64_t)fim_ctr;
    g_fmtd16 = fmtd16;
    g_ridx = 0;
#endif
    FimBlockInfo* fbi = &vega20_fbi;
    int out_dim = size / fbi->trans_size;

    /* Radeon7(VEGA20) memory is 16GB but our target is 32GB system */
    /* so program_crf and chagne_fim_mode functions can not access to over 8GB in our system */
    park_in(fim_ctr);
    change_fim_mode(fim_ctr, SB_MODE, HAB_MODE);
    program_crf(fim_ctr, elt_add_crf, sizeof(elt_add_crf));
    change_fim_mode(fim_ctr, HAB_MODE, HAB_FIM_MODE);
    compute_elt_add(fim_data, get_num_tile(out_dim));
    change_fim_mode(fim_ctr, HAB_FIM_MODE, HAB_MODE);
    change_fim_mode(fim_ctr, HAB_MODE, SB_MODE);
    park_out(fim_ctr);
    read_result(output, fim_data, FimBankType::ODD_BANK,  out_dim, 0, get_result_col(out_dim));
#ifdef EMULATOR
    frd_size[0] = g_ridx;
#endif
}

#ifdef EMULATOR
__global__ void elt_add_fim_emul(uint8_t* fim,
                                 uint8_t* cmode,
                                 uint8_t* cmd,
                                 unsigned int start_row,
                                 unsigned int input_size,
                                 FimMemTraceData* mt,
                                 int mt_width)
{
    int num_blk = 8;
    int num_g = 8;
    int num_col = 32;
    int num_bg = 4;
    int num_ch = hipGridDim_x;
    int num_ba = 16;
    int num_rank = 1;
    int g_size = 32;

    int num_p = num_blk * num_ch * num_g * (g_size / sizeof(short));
    int num_t = input_size / num_p;

    uint64_t addr;
    uint64_t offset = (hipThreadIdx_x % 2) * 0x10;

    __shared__ int m_idx[64];
    m_idx[hipThreadIdx_x] = 0;
    __syncthreads();

    __shared__ uint64_t cmode_s[4];
    __shared__ uint64_t cmd_s[4];

    if (hipThreadIdx_x < 4) {
        cmode_s[hipThreadIdx_x] = ((uint64_t*)cmode)[hipThreadIdx_x];
    }
    if (hipThreadIdx_x < 4) {
        cmd_s[hipThreadIdx_x] = ((uint64_t*)cmd)[hipThreadIdx_x];
    }
    __syncthreads();

    if (hipThreadIdx_x < num_bg * 2) {
        addr = addr_gen(hipBlockIdx_x, 0, (hipThreadIdx_x / 2), 0, (1 << 12), 0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'R', addr + offset, 0, 0);

        addr = addr_gen(hipBlockIdx_x, 0, (hipThreadIdx_x / 2), 1, (1 << 12), 0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'R', addr + offset, 0, 0);

        addr = addr_gen(hipBlockIdx_x, 0, (hipThreadIdx_x / 2), 2, (1 << 12), 0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'R', addr + offset, 0, 0);

        addr = addr_gen(hipBlockIdx_x, 0, (hipThreadIdx_x / 2), 3, (1 << 12), 0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'R', addr + offset, 0, 0);
    }
    record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'B', 0, 0, 0);
    __syncthreads();

    if (hipThreadIdx_x < 2) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 0, 0x17ff, 0x1f);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'W', addr + offset, 0, 0);

        addr = addr_gen(hipBlockIdx_x, 0, 0, 1, 0x17ff, 0x1f);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'W', addr + offset, 0, 0);

        addr = addr_gen(hipBlockIdx_x, 0, 2, 0, 0x17ff, 0x1f);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'W', addr + offset, 0, 0);

        addr = addr_gen(hipBlockIdx_x, 0, 2, 1, 0x17ff, 0x1f);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'W', addr + offset, 0, 0);
    }
    record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'B', 0, 0, 0);
    __syncthreads();

    if (hipThreadIdx_x == 0) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 1, 0x3fff, 0x4);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'W', addr + offset, cmd_s[0], cmd_s[1]);
    }
    else if (hipThreadIdx_x == 1) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 1, 0x3fff, 0x4);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'W', addr + offset, cmd_s[2], cmd_s[3]);
    }
    record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'B', 0, 0, 0);
    __syncthreads();

    if (hipThreadIdx_x == 0) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 0, 0x3fff, 0x0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'W', addr + offset, cmode_s[0], cmode_s[1]);
    }
    else if (hipThreadIdx_x == 1) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 0, 0x3fff, 0x0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'W', addr + offset, cmode_s[2], cmode_s[3]);
    }
    record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'B', 0, 0, 0);
    __syncthreads();

    for (int tile_idx = 0; tile_idx < num_t; tile_idx++) {
        unsigned int loc = tile_idx * num_g + (hipThreadIdx_x / 2);
        unsigned int row = start_row + loc / num_col;
        unsigned int col = loc % num_col;

        addr = addr_gen(hipBlockIdx_x, 0, 0, 0, row, col);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'R', addr + offset, 0, 0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'B', 0, 0, 0);
        __threadfence();

        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'R', addr + 0x2000 + offset, 0, 0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'B', 0, 0, 0);
        __threadfence();

        unsigned int output_loc = loc + num_t * num_g;
        unsigned int output_row = start_row + output_loc / num_col;
        unsigned int output_col = output_loc % num_col;

        addr = addr_gen(hipBlockIdx_x, 0, 0, 1, output_row, output_col);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'W', addr + offset, 0, 0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'B', 0, 0, 0);
        __threadfence();
    }

    if (hipThreadIdx_x < 2) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 0, 0x3fff, 0x0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'W', addr + offset, 0, 0);
    }
    record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'B', 0, 0, 0);
    __syncthreads();

    if (hipThreadIdx_x < 4) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, hipThreadIdx_x / 2, 0x1fff, 0x1f);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'W', addr + offset, 0, 0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'B', 0, 0, 0);
        __threadfence();

        addr = addr_gen(hipBlockIdx_x, 0, 0, hipThreadIdx_x / 2, (1 << 12), 0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'R', addr + offset, 0, 0);
        record(fim, mt, mt_width, hipBlockIdx_x, hipThreadIdx_x, atomicAdd(&m_idx[0], 1), 'B', 0, 0, 0);
        __threadfence();
    }

    if (hipBlockIdx_x == 0 && hipThreadIdx_x == 0) {
        unsigned int cidx = 0;
        unsigned int rank = 0;
        unsigned int bg = 0;
        unsigned int ba = 0;
        unsigned int rst_col = (input_size / 16) / (num_blk * num_ch * num_rank);

        for (int i = 0; i < num_ch; i++) {
            m_idx[i] = m_idx[0];
        }

        for (int x = 0; x < (input_size / 16); x += num_g) {
            unsigned int row = start_row;
            unsigned int col = rst_col;

            for (int g_idx = 0; g_idx < num_g; g_idx++) {
                addr = addr_gen(cidx, rank, bg, ba + 1, row, col);
                record(fim, mt, mt_width, cidx, 0, m_idx[cidx]++, 'O', addr, 0, 0);
                record(fim, mt, mt_width, cidx, 0, m_idx[cidx]++, 'O', addr + 0x10, 0, 0);
                col++;
            }

            ba += (num_ba / num_blk);
            if (ba >= (num_ba / num_bg)) {
                bg++;
                ba = 0;
            }
            if (bg >= num_bg) {
                bg = 0;
                rank++;
            }
            if (rank >= num_rank) {
                rank = 0;
                cidx++;
            }
            if (cidx >= num_ch) {
                cidx = 0;
                start_row = row;
                rst_col = col;
            }
        }
    }
}
#endif
#endif /* _FIM_OP_KERNELS_FIMK_ */
