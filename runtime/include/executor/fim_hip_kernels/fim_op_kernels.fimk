#ifndef _FIM_OP_KERNELS_FIMK_
#define _FIM_OP_KERNELS_FIMK_

#include "fim_crf_bins.h"
#include "fim_data_types.h"
#include "utility/fim_util.h"

#ifdef EMULATOR
uint64_t g_fba;
FimMemTraceData* g_fmtd16;
int g_ridx;
int g_idx[64];
int m_width;
#endif

__global__ void dummy_kernel(void) {}

__global__ void gemv_fim_1cu_2th_fp16(volatile uint8_t* __restrict__ fim_ctr, volatile uint8_t* __restrict__ fim_weight,
                                      volatile uint8_t* __restrict__ fim_gemv_tmp_buffer,
                                      volatile uint8_t* __restrict__ fim_input, volatile uint8_t* __restrict__ output,
                                      int input_dim, int output_dim, FimMemTraceData* fmtd16, int* frd_size,
                                      uint8_t* crf_binary, int crf_size)
{
#ifdef EMULATOR
    g_fba = (uint64_t)fim_ctr;
    g_fmtd16 = fmtd16;
    g_ridx = 0;
    uint64_t offset = (hipThreadIdx_x % 2) * 0x10;
    __syncthreads();
#endif
    FimBlockInfo* fbi = &vega20_fbi;
    input_dim = input_dim * sizeof(half) / fbi->trans_size;
    int num_parallelism = fbi->num_fim_blocks * fbi->num_fim_chan * fbi->num_fim_rank;
    int num_output_bst = output_dim;
    int num_out_tile = ceilf((float)num_output_bst / (float)num_parallelism) / fbi->num_grf_B;
    int num_in_tile = ceilf((float)input_dim / (float)fbi->num_grf_A);
    int num_jump_of_even_bank = fbi->num_grf_B * ceilf((float)num_in_tile / 2) - 1;
    int num_jump_of_odd_bank = fbi->num_grf_B * floorf((float)num_in_tile / 2) - 1;
    int end_col = gemv_get_result_col(input_dim / fbi->trans_size, num_output_bst, num_in_tile, num_out_tile);
    int compute_col = 0;

    /* Radeon7(VEGA20) memory is 16GB but our target is 32GB system */
    /* so program_crf and chagne_fim_mode functions can not access to over 8GB in our system */
    park_in_1cu_2th(fim_ctr, offset);
    change_fim_mode_1cu_2th(fim_ctr, SB_MODE, HAB_MODE, null_bst, offset);
    program_crf_1cu_2th(fim_ctr, crf_binary, crf_size, offset);
    for (int j = 0; j < num_out_tile; j++) {
        change_fim_mode_1cu_2th(fim_ctr, HAB_MODE, HAB_FIM_MODE, gemv_hab_to_hab_fim, offset);
        for (int i = 0; i < num_in_tile; i += 2) {
            compute_gemv_2bank_1cu_2th(fim_ctr, fim_weight, fim_input, num_in_tile / 2, num_out_tile, i, j, EVEN_BANK,
                                       offset);
        }
        for (int i = 1; i < num_in_tile; i += 2) {
            compute_gemv_2bank_1cu_2th(fim_ctr, fim_weight, fim_input, num_in_tile / 2, num_out_tile, i, j, ODD_BANK,
                                       offset);
        }
        compute_col = num_out_tile * num_in_tile / 2 * fbi->num_grf_A * fbi->num_grf_B + j * fbi->num_grf_B;
        add_transaction_all_1cu_2th(fim_ctr, true, 0, 1, 0, compute_col, null_bst, offset, fbi->num_grf);
        change_fim_mode_1cu_2th(fim_ctr, HAB_FIM_MODE, HAB_MODE, gemv_hab_fim_to_hab, offset);
    }
    change_fim_mode_1cu_2th(fim_ctr, HAB_MODE, SB_MODE, null_bst, offset);
    park_out_1cu_2th(fim_ctr, offset);
    read_result_1cu_2th(fim_gemv_tmp_buffer, fim_weight, ODD_BANK, num_output_bst, 0, end_col, offset);
#ifdef EMULATOR
    __syncthreads();
    frd_size[0] = g_ridx;
#endif

#if 0 /* TODO: verify reduce sum in Target Mode */
    if (hipThreadIdx_x == 0) {
        reduce_sum_for_gemv((void*)output, (void*)fim_gemv_tmp_buffer, output_dim * fbi->num_out_per_grf * 2, fbi->num_out_per_grf);
    }
#endif
}

__global__ void elt_add_fim_1cu_2th_fp16(volatile uint8_t* __restrict__ fim_data,
                                         volatile uint8_t* __restrict__ fim_ctr, volatile uint8_t* __restrict__ output,
                                         int size, FimMemTraceData* fmtd16, int* frd_size, int mt_width)
{
#ifdef EMULATOR
    g_fba = (uint64_t)fim_ctr;
    g_fmtd16 = fmtd16;
    g_ridx = 0;
    uint64_t offset = (hipThreadIdx_x % 2) * 0x10;
    __syncthreads();
#endif
    FimBlockInfo* fbi = &vega20_fbi;
    int out_dim = size / fbi->trans_size;

    /* Radeon7(VEGA20) memory is 16GB but our target is 32GB system */
    /* so program_crf and chagne_fim_mode functions can not access to over 8GB in our system */
    park_in_1cu_2th(fim_ctr, offset);
    change_fim_mode_1cu_2th(fim_ctr, SB_MODE, HAB_MODE, null_bst, offset);
    program_crf_1cu_2th(fim_ctr, elt_add_crf, sizeof(elt_add_crf), offset);
    change_fim_mode_1cu_2th(fim_ctr, HAB_MODE, HAB_FIM_MODE, elt_add_hab_to_hab_fim, offset);
    compute_elt_op_1cu_2th(fim_data, get_num_tile(out_dim), offset);
    change_fim_mode_1cu_2th(fim_ctr, HAB_FIM_MODE, HAB_MODE, elt_add_hab_fim_to_hab, offset);
    change_fim_mode_1cu_2th(fim_ctr, HAB_MODE, SB_MODE, null_bst, offset);
    park_out_1cu_2th(fim_ctr, offset);
    read_result_1cu_2th(output, fim_data, FimBankType::ODD_BANK, out_dim, 0, get_result_col(out_dim), offset);
#ifdef EMULATOR
    __syncthreads();
    frd_size[0] = g_ridx;
#endif
}

__global__ void elt_add_fim(uint8_t* fim_data, uint8_t* fim_ctr, uint8_t* output, unsigned int input_size,
                            FimMemTraceData* fmtd, int* frd_size, int mt_width, uint8_t* crf_binary, int crf_size)
{
#ifdef EMULATOR
    g_idx[hipBlockIdx_x] = 0;
    g_fba = (uint64_t)fim_ctr;
    g_fmtd16 = fmtd;
    m_width = mt_width;
#endif
    FimBlockInfo* fbi = &vega20_fbi;
    int num_blk = fbi->num_fim_blocks;
    int num_g = fbi->num_grf;
    int num_bg = fbi->num_bank_groups;
    int num_ba = fbi->num_banks;
    int num_ch = hipGridDim_x;
    int num_rank = 1;
    int num_col = 32;
    int g_size = 32;
    int i_size = input_size / sizeof(short);
    unsigned int start_row = (((uint64_t)fim_ctr - (uint64_t)fim_data) >> 19) & 0x3FFF;

    int num_p = num_blk * num_ch * num_g * (g_size / sizeof(short));
    int num_t = i_size / num_p;

    uint64_t addr;
    uint64_t offset = (hipThreadIdx_x % 2) * 0x10;

    B_CMD(0);
    if (hipThreadIdx_x < num_bg * 2) {
        addr = addr_gen(hipBlockIdx_x, 0, (hipThreadIdx_x / 2), 0, (1 << 12), 0);
        R_CMD(&fim_ctr[addr + offset]);

        addr = addr_gen(hipBlockIdx_x, 0, (hipThreadIdx_x / 2), 1, (1 << 12), 0);
        R_CMD(&fim_ctr[addr + offset]);

        addr = addr_gen(hipBlockIdx_x, 0, (hipThreadIdx_x / 2), 2, (1 << 12), 0);
        R_CMD(&fim_ctr[addr + offset]);

        addr = addr_gen(hipBlockIdx_x, 0, (hipThreadIdx_x / 2), 3, (1 << 12), 0);
        R_CMD(&fim_ctr[addr + offset]);
    }
    B_CMD(0);

    if (hipThreadIdx_x < 2) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 0, 0x17ff, 0x1f);
        W_CMD(&fim_ctr[addr + offset]);

        addr = addr_gen(hipBlockIdx_x, 0, 0, 1, 0x17ff, 0x1f);
        W_CMD(&fim_ctr[addr + offset]);

        addr = addr_gen(hipBlockIdx_x, 0, 2, 0, 0x17ff, 0x1f);
        W_CMD(&fim_ctr[addr + offset]);

        addr = addr_gen(hipBlockIdx_x, 0, 2, 1, 0x17ff, 0x1f);
        W_CMD(&fim_ctr[addr + offset]);
    }
    B_CMD(0);

    if (hipThreadIdx_x < 2 * crf_size) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 1, 0x3fff, 0x4 + hipThreadIdx_x / 2);
        W_CMD_R(&fim_ctr[addr + offset], crf_binary + hipThreadIdx_x * 16);
    }
    B_CMD(0);

    if (hipThreadIdx_x == 0) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 0, 0x3fff, 0x0);
        W_CMD_R(&fim_ctr[addr + offset], elt_add_hab_to_hab_fim);
    } else if (hipThreadIdx_x == 1) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 0, 0x3fff, 0x0);
        W_CMD_R(&fim_ctr[addr + offset], elt_add_hab_to_hab_fim + 16);
    }
    B_CMD(0);

    for (int tile_idx = 0; tile_idx < num_t; tile_idx++) {
        unsigned int loc = tile_idx * num_g + (hipThreadIdx_x / 2);
        unsigned int row = start_row + loc / num_col;
        unsigned int col = loc % num_col;

        addr = addr_gen(hipBlockIdx_x, 0, 0, 0, row, col);
        R_CMD(&fim_ctr[addr + offset]);
        B_CMD(1);

        R_CMD(&fim_ctr[addr + 0x2000 + offset]);
        B_CMD(1);

        unsigned int output_loc = loc + num_t * num_g;
        unsigned int output_row = start_row + output_loc / num_col;
        unsigned int output_col = output_loc % num_col;

        addr = addr_gen(hipBlockIdx_x, 0, 0, 1, output_row, output_col);
        W_CMD(&fim_ctr[addr + offset]);
        B_CMD(1);
    }

    if (hipThreadIdx_x == 0) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 0, 0x3fff, 0x0);
        W_CMD_R(&fim_ctr[addr + offset], elt_add_hab_fim_to_hab);
    } else if (hipThreadIdx_x == 1) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, 0, 0x3fff, 0x0);
        W_CMD_R(&fim_ctr[addr + offset], elt_add_hab_fim_to_hab + 16);
    }
    B_CMD(0);

    if (hipThreadIdx_x < 4) {
        addr = addr_gen(hipBlockIdx_x, 0, 0, hipThreadIdx_x / 2, 0x1fff, 0x1f);
        W_CMD(&fim_ctr[addr + offset]);
        B_CMD(1);

        addr = addr_gen(hipBlockIdx_x, 0, 0, hipThreadIdx_x / 2, (1 << 12), 0);
        R_CMD(&fim_ctr[addr + offset]);
        B_CMD(1);
    }

#ifdef EMULATOR
    if (hipBlockIdx_x == 0 && hipThreadIdx_x == 0) {
        unsigned int cidx = 0;
        unsigned int rank = 0;
        unsigned int bg = 0;
        unsigned int ba = 0;
        unsigned int rst_col = (i_size / 16) / (num_blk * num_ch * num_rank);

        for (int x = 0; x < (i_size / 16); x += num_g) {
            unsigned int row = start_row;
            unsigned int col = rst_col;

            for (int i = 0; i < num_g; i++) {
                addr = addr_gen(cidx, rank, bg, ba + 1, row, col);
                record(cidx, 'O', addr);
                record(cidx, 'O', addr + 0x10);
                col++;
            }

            ba += (num_ba / num_blk);
            if (ba >= (num_ba / num_bg)) {
                bg++;
                ba = 0;
            }
            if (bg >= num_bg) {
                bg = 0;
                rank++;
            }
            if (rank >= num_rank) {
                rank = 0;
                cidx++;
            }
            if (cidx >= num_ch) {
                cidx = 0;
                start_row = row;
                rst_col = col;
            }
        }
    }

    *frd_size = g_idx[0];
#endif
}

__global__ void elt_mul_fim_1cu_2th_fp16(volatile uint8_t* __restrict__ fim_data,
                                         volatile uint8_t* __restrict__ fim_ctr, volatile uint8_t* __restrict__ output,
                                         int size, FimMemTraceData* fmtd16, int* frd_size, int mt_width,
                                         uint8_t* crf_binary, int crf_size)
{
#ifdef EMULATOR
    g_fba = (uint64_t)fim_ctr;
    g_fmtd16 = fmtd16;
    g_ridx = 0;
    uint64_t offset = (hipThreadIdx_x % 2) * 0x10;
    __syncthreads();
#endif
    FimBlockInfo* fbi = &vega20_fbi;
    int out_dim = size / fbi->trans_size;

    /* Radeon7(VEGA20) memory is 16GB but our target is 32GB system */
    /* so program_crf and chagne_fim_mode functions can not access to over 8GB in our system */
    park_in_1cu_2th(fim_ctr, offset);
    change_fim_mode_1cu_2th(fim_ctr, SB_MODE, HAB_MODE, null_bst, offset);
    program_crf_1cu_2th(fim_ctr, crf_binary, crf_size, offset);
    change_fim_mode_1cu_2th(fim_ctr, HAB_MODE, HAB_FIM_MODE, elt_mul_hab_to_hab_fim, offset);
    compute_elt_op_1cu_2th(fim_data, get_num_tile(out_dim), offset);
    change_fim_mode_1cu_2th(fim_ctr, HAB_FIM_MODE, HAB_MODE, elt_mul_hab_fim_to_hab, offset);
    change_fim_mode_1cu_2th(fim_ctr, HAB_MODE, SB_MODE, null_bst, offset);
    park_out_1cu_2th(fim_ctr, offset);
    read_result_1cu_2th(output, fim_data, FimBankType::ODD_BANK, out_dim, 0, get_result_col(out_dim), offset);
#ifdef EMULATOR
    __syncthreads();
    frd_size[0] = g_ridx;
#endif
}

__global__ void relu_fim_1cu_2th_fp16(volatile uint8_t* __restrict__ fim_data, volatile uint8_t* __restrict__ fim_ctr,
                                      volatile uint8_t* __restrict__ output, int size, FimMemTraceData* fmtd16,
                                      int* frd_size, int mt_width, uint8_t* crf_binary, int crf_size)
{
#ifdef EMULATOR
    g_fba = (uint64_t)fim_ctr;
    g_fmtd16 = fmtd16;
    g_ridx = 0;
    uint64_t offset = (hipThreadIdx_x % 2) * 0x10;
    __syncthreads();
#endif
    FimBlockInfo* fbi = &vega20_fbi;
    int out_dim = size / fbi->trans_size;
    int end_col = get_result_col(out_dim / 2);

    /* Radeon7(VEGA20) memory is 16GB but our target is 32GB system */
    /* so program_crf and chagne_fim_mode functions can not access to over 8GB in our system */
    park_in_1cu_2th(fim_ctr, offset);
    change_fim_mode_1cu_2th(fim_ctr, SB_MODE, HAB_MODE, null_bst, offset);
    program_crf_1cu_2th(fim_ctr, crf_binary, crf_size, offset);
    change_fim_mode_1cu_2th(fim_ctr, HAB_MODE, HAB_FIM_MODE, relu_hab_to_hab_fim, offset);
    compute_relu_1cu_2th(fim_data, get_num_tile(out_dim) / 2, offset);
    change_fim_mode_1cu_2th(fim_ctr, HAB_FIM_MODE, HAB_MODE, relu_hab_fim_to_hab, offset);
    change_fim_mode_1cu_2th(fim_ctr, HAB_MODE, SB_MODE, null_bst, offset);
    park_out_1cu_2th(fim_ctr, offset);
    read_result_2bank_1cu_2th(output, fim_data, out_dim, 0, end_col, offset);
#ifdef EMULATOR
    __syncthreads();
    frd_size[0] = g_ridx;
#endif
}

#endif /* _FIM_OP_KERNELS_FIMK_ */
